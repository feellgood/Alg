#include <random>

#include <boost/progress.hpp>
#include <boost/format.hpp>
#include <boost/tokenizer.hpp>

#include "gmm/gmm.h"

#include "alg.h"

using namespace gmm;
typedef gmm::row_matrix	<std::vector<double> >   write_matrix;
typedef gmm::row_matrix	<std::vector<double> >    read_matrix;

//void cg_dir(const read_matrix& A, write_vector& x, const read_vector& b, const vector<size_t>& ld, diagonal_precond <read_matrix> &P, iteration &iter)
void cg_dir(const read_matrix& A, std::vector<double> & x, const std::vector<double> & b, const std::vector<size_t>& ld, diagonal_precond <read_matrix> &P, iteration &iter) 
{
double rho, rho_1(0.0);
std::vector<double> p(x.size()),q(x.size()),r(x.size()),z(x.size());
    
iter.set_rhsnorm(alg::norm(b));//iter.set_rhsnorm(gmm::sqrt(gmm::abs(vect_sp(b, b))));

	
//      mult(A, scaled(x, -1.0), b, r);// r = b - A x
	
r.assign(b.begin(),b.end());// r = b;
std::vector<double> v_temp(x.size()); 
mult(A,x,v_temp);// v_temp = A x;
alg::dec(v_temp,r);// r -= v_temp; donc r = b - A x;

std::for_each(ld.begin(),ld.end(),[&r,&P](const size_t _i){ r[_i] = 0.0; P.diag[_i] = 0.0; });

      mult(P, r, z);
      rho = alg::p_scal(z,r);//rho = vect_sp(z, r);
      p.assign(z.begin(),z.end());//copy(z, p);

      while (!iter.finished_vect(r)) {

	      if (!iter.first()) { 
 
	         mult(P, r, z);
	         rho = alg::p_scal(z,r);//rho = vect_sp(z, r);
	         
		//add(z, scaled(p, rho/rho_1), p);// p = z + (rho/rho_1)*p
		alg::scaled(rho/rho_1,p); // p *= (rho/rho1)
		alg::inc(z,p);// p += z	         
		}
	      mult(A, p, q);
          
	//for (vector<size_t>::const_iterator it=ld.begin(); it!=ld.end(); ++it){ q[*it]=0.0; }
	std::for_each(ld.begin(),ld.end(),[&q](size_t _i){q[_i] = 0.0; } );	      
	double a=rho/alg::p_scal(q,p); //a = rho / vect_sp(q, p);	
	alg::scaled_inc(p, +a, x); //add(scaled(p, +a), x);

	alg::scaled_inc(q, -a, r);//add(scaled(q, -a), r);
	      rho_1 = rho;
	      ++iter;
          }   
  }


int main()
{
boost::timer time;
const int  VERBOSE = 0;
const int MAXITER = 5000;

const int NOD=101;
std::vector<size_t> ld;
std::vector<double> Vd(NOD, 0.);

write_matrix Kw(NOD, NOD);

std::vector<double> Lw(NOD); //write_vector Lw(NOD);

std::vector<double> Xw(NOD,0.0);//write_vector Xw(NOD);


std::random_device rd;  //Will be used to obtain a seed for the random number engine
std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
std::uniform_int_distribution<> distrib(0, 1000);

Kw(0,     0    )=+1.0;  Kw(0,     1    )=-1.0;
Kw(NOD-1, NOD-2)=-1.0;  Kw(NOD-1, NOD-1)=+1.0;

for (int n=1; n<NOD-1; ++n){
    Kw(n, n-1)=-1.0;  Kw(n, n  )=+2.0; Kw(n, n+1)=-1.0;
//Use `distrib` to transform the random unsigned int generated by gen 
    double r= double(distrib(gen))/1000.;
/*
    if (r>0.7){
       ld.push_back(n);
       Vd[n]=1.0;
       }
*/
}
ld.push_back(0);
Vd[0]=0.0;

ld.push_back(NOD-1);
Vd[NOD-1]=1.0;

// valeurs de dirichlet inserees dans le vecteur solution
std::for_each(ld.begin(),ld.end(),[&Xw,&Vd] (size_t _i){ Xw[_i] = Vd[_i]; } );

read_matrix  Kr(NOD, NOD);    gmm::copy(Kw, Kr);

std::vector<double> Lr(NOD,0.0);//read_vector  Lr(NOD);         
Lr.assign(Lw.begin(),Lw.end());//gmm::copy(Lw, Lr);

mult(Kr, Xw, Lw);

alg::scaled(Lw,-1.0,Lr);//add(scaled(Lw, -1.0), Lr);//Lr = -Lw

std::cout << boost::format("%5t preconditioning %50T.") << std::flush;
time.restart();
gmm::diagonal_precond <read_matrix> prc(Kr);
std::cout << "time elapsed : " << time.elapsed() << std::endl;

std::cout << boost::format("%5t solving %50T.") << std::flush;
//cout << "\t solving .......................... ";
time.restart();

gmm::iteration iter(1e-6);
iter.set_maxiter(MAXITER);
iter.set_noisy(VERBOSE);

gmm::clear(Xw);
cg_dir(Kr, Xw, Lr, ld, prc, iter); // Conjugate gradient with dirichlet conditions
std::cout << "finished " << iter.get_iteration() << std::endl; 

cout << "time elapsed : "<< time.elapsed() << endl;

for (int i=0; i<NOD; i+=10) { std::cout << i << "\t" << Xw[i]+Vd[i] << "\t" << Vd[i] << std::endl; }

return 0;
}


